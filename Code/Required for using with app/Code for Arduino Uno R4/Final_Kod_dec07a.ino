#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/58e2d3d4-3f02-476b-a03a-761da3c58c3e 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float moisture;
  int cutoff;
  int flow;
  CloudSchedule timer;
  bool watering;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include "Adafruit_seesaw.h"
#include "RTC.h"

// Assigns the moisture sensor the name ss through the I2C ports
Adafruit_seesaw ss;

// Assign the pump on pin 6
int pump = 6;

// Assign analog readings for temp sensor
const int analogRealValuePin = A3;

// Assign fan control pin
const int fanControlPin = 3;


void setup() {

//Prevent the digital pin from having an output during bootup. This caused issues initially 
  pinMode(pump, INPUT_PULLUP);
  
// Initialize serial and wait for port to open:
  Serial.begin(115200);
// This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1000); 
// Initialize Serial1 which is needed to communicate through TX -> RX serial bus
  Serial1.begin(115200);
  delay(1000);   

// Assign fan control pin
  pinMode(fanControlPin, OUTPUT);

// For testing, will make arduino LED turn on in order to test code
  pinMode(LED_BUILTIN, OUTPUT);

// Setups and starts the Moisture Sensor
  if (!ss.begin(0x36)) {
    Serial.println("ERROR! seesaw not found");
    while(1) delay(1);
  } else {
    Serial.print("seesaw started! version: ");
    Serial.println(ss.getVersion(), HEX);
  }
  
// Start the internal Real Time Clock. 
  RTC.begin(); 
  

// Used to setup the date/time. Hide this whenever the time doesn't need to be updated. startTime(day,month,year,hour,minutes,seconds) 
//  RTCTime startTime(10, Month::DECEMBER, 2023, 23, 18, 00, DayOfWeek::MONDAY, SaveLight::SAVING_TIME_ACTIVE);
//  RTC.setTime(startTime);
  
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  
//Make Moisture 100 on start so it won't water the plant on startup
  moisture = 100;
  
// Assign Pump pin as output
  pinMode(pump, OUTPUT);
}

// Highest and lowest range for the moisture sensor
float max_capread = 1015 ;
float min_capread = 300;

// Variables used to only make the program run once every hour, value will represent the last hour plant was watered. Initial value outsie of range to triffer on startup
int last_hour_control = 100;

// Variable that stores the previous change in LED lights. Used so it won't send Serial signals every loop to the arduino NANO
char last_led_stage = '9';

// "button" variable that activates code in the void loop after the IOT Cloud manual watering button has been pushed
int button = 0;

// Dictates whenever the fan is on or off
int led_status = 0;

// Value that creates a moisture average
float moist_average = 0;

// This variable keeps track of how many samples are taken for the average. Will reset at 10.
float number_average = 0;

//Value that keeps track of the last second (initially outside range)
//int last_second = 61;

void loop() {
// Used to update changes from the cloud
  ArduinoCloud.update();
  
// Function that adds the correct wait time for the pump to pump equal volume of water as the "flow" value from the wifi interface
  int flow_delay = 347 + (43.85 * flow);

// Manual watering that activates the pump for "flow_delay" set of ms after pressing the button in the app
  if (button >= 2) {
    digitalWrite(pump, HIGH);
    digitalWrite(LED_BUILTIN,HIGH);
    Serial.println("Pump has been manually activated");
    delay(flow_delay);
    digitalWrite(pump, LOW);
    digitalWrite(LED_BUILTIN,LOW);
    button = 0;
  }

// Take reading from the moisture sensor. Temperature won't be needed for this project
//  float tempC = ss.getTemp();
  uint16_t capread = ss.touchRead(0);

// currentTime takes the values from the RTC clock and updates each loop
  RTCTime currentTime;
  RTC.getTime(currentTime);

// Create a percentage value from the moisture sensor
  float capread_percentage = ((capread - min_capread) / (max_capread-min_capread)) * 100 ;

//Below is the code for the cooling fan for the LEDs
//Turns off the fans when the LED is off
  if (led_status == 0) {
    analogWrite(fanControlPin, 0);
  }

//Turns on the fan when the LED is on
  if (led_status == 1) {
// Values from sensor
    float realValue = analogRead(analogRealValuePin);
    
// Convert analog reading to voltages
    float realVoltage = (realValue / 1023.0) * 5.0;
  
// Convert voltages to temperatures using 11.5x + 18.7
    float realValueTemp = (11.5 * realVoltage)+18.7;

// Alternative interpitation of the temperature    
    float temperature = (160*realVoltage -657);
    
// Assign setpointValueTemp, limit for when fans will kick it up a notch
    float setpointValueTemp = 30;

// Sees if the temperature is bigger than "setpointValueTemp"
    float tempDifference = realValueTemp - (setpointValueTemp);
  
// Below is the range in order to control the fan speed
    if (tempDifference <= 1) {
      analogWrite(fanControlPin, 255);
    }

    else if (tempDifference > 1) {
      analogWrite(fanControlPin, 255);
    }

// Can be used for monitoring the fan system, good for troubleshooting
//    Serial.println(analogRealValuePin);
//    Serial.println(realValue);
//    Serial.println(realVoltage);
//    Serial.println(realValueTemp);
//    Serial.print("Temperature:"); Serial.println(temperature);
//    Serial.println("_______________");
//    Serial.println(tempDifference);
  
  }

// Reset the sensor if it crashes, value is outside of the reading range. Sensor gets stuck on really high value when it crashes
  if (capread > 2000) {
    Serial.println("Moisture sensor has encountered an error and is restarting");
    ss.begin(0x36);
    delay(5000);
  }

/* 
// Overwrite the cloud moisture value with 10 reading average from the sensor. 10 plot average over 10 seconds. Won't capture readings outside of the 100% range.
  if (capread_percentage <= 100 && currentTime.getSeconds() != last_second) {
    moist_average = moist_average + capread_percentage;
    last_second = currentTime.getSeconds();
    if (currentTime.getSeconds() % 10 ==0) {
      int average = moist_average/10;
      if (average <= 100) {
        moisture = average;
      moist_average = 0;
      }
    }
  }
*/
// Make a 10 plot average from the moisture sensor to initiate the moisture level
  if (capread_percentage <= 100) {
    moist_average = moist_average + capread_percentage;
    number_average = number_average +1;
    Serial.println(moist_average);
    Serial.println(number_average);
    if (number_average == 10){
      moisture = (moist_average / 10);
      number_average = 0;
      moist_average = 0;
    }
  }

// Below is the automatic watering code. Has a timer that looks at the moisture value every hour and compares it to the "cutoff" value from the cloud.
// Will excetute the loop once an hour, and update the "last_hour_control"
  if (currentTime.getHour() % 1 == 0 && last_hour_control != currentTime.getHour()) {
    last_hour_control = currentTime.getHour();
// Sees if the moisture sensor has dipped below the assigned cutoff value from the cloud
    if (moisture < float(cutoff)) {
      
// This is the code that will initiate the pump, which water quantity is dictated by the "flow_delay" cloud variable
      digitalWrite(pump, HIGH);
      Serial.println("Pump has been automatically activated");
      delay(flow_delay);
      digitalWrite(pump, LOW);
    }
  }



// Whenever the timer is active, the LEDs will turn on and vice versa. Sends a serial signal to NANO through the TX->RX pins to update its state
  if (timer.isActive() == 1 && last_led_stage != '1') {
    Serial1.write('1');
    led_status = 1;
    Serial.println("LED automatically turned on from timer");
    digitalWrite(LED_BUILTIN,HIGH);
    last_led_stage = '1';
  }
  else if (timer.isActive() == 0 && last_led_stage != '0'){
    Serial1.write('0');
    led_status = 0;
    Serial.println("LED automatically turned off from timer");
    digitalWrite(LED_BUILTIN,LOW);
    last_led_stage = '0';
  }
  
// Print values from the system in order for monetering
//  Serial.print("Temperature: "); Serial.print(tempC); Serial.println("C");
//  Serial.print("Capacitive: "); Serial.println(capread);
//  Serial.print("Moisture(%): "); Serial.print(capread_percentage); Serial.println("%");
//  Serial.print("Time: "); Serial.print(currentTime.getHour()); Serial.print(":"); Serial.println(currentTime.getMinutes());
  
// Delays the whole systen for 1 second
  delay(1000);
  
}

// Below are all the cloud variables that activates everytime there is a change from the IOT cloud

void onWateringChange()  {
// Manual watering will activate in the loop when "button" variable ha been released, other words button >= 2
  button = button + 1;
}


void onCutoffChange()  {
  // Add your code here to act upon Cutoff change
}

void onTimerChange()  {
// Code that activates when there is a change to the timer
  if (timer.isActive()) {
    Serial1.write('1');
    led_status = 1;
    Serial.println("The LED has been turned on manually");
    digitalWrite(LED_BUILTIN,HIGH);
    
  }
  else {
    Serial1.write('0');
    led_status = 0;
    Serial.println("The LED has been turned off manually");
    digitalWrite(LED_BUILTIN,LOW);
  }

}

void onFlowChange()  {
// Updates the "flow_delay" whenever changed
//  int flow_delay = 347 + (43.85 * flow);
}
